%% Test Class Definition
classdef UnitTestTrafficDensity < matlab.unittest.TestCase
% Copyright 2019 - 2023, MIT Lincoln Laboratory
% SPDX-License-Identifier: X11
%
% UnitTestTrafficDensity takes in simple (fabricated) data and outputs
% density (both yearly averages and maximum observed occupancy) for both
% cooperative and noncooperative intruders. Collision risk is also computed
% for a test trajectory.
    
    %% Test Method Block
    % https://www.mathworks.com/help/matlab/matlab_prog/author-class-based-unit-tests-in-matlab.html
    methods (Test)
        function testGenerateDensity(testCase) 
            % Test that tool properly computes traffic density
            %% Set up save directory    
            saveDirectory = [getenv('TrafficDensityPath') filesep 'Testing' filesep 'Results' filesep]; % Directory where plots will be saved
            if ~exist(saveDirectory,'dir')
                mkdir(saveDirectory); % Create saveDirectory
            end
            
            close all; % Close all existing plots so we can save the ones generated by the traffic density unit test

            %% Generate density for simple data
            disp('***Running Density Test***');

            % Load test data (Features: TotalTime/MaxOcc is 1's for altitude layer
            % 1, all 2's altitude layer 2, etc.)

            % Set up parameters
            airspace = {'All','A','B','C','D','O'}; % 'All' --> every cell is 20% of each airspace; 'A','B','C','D','O' --> data is entirely specified airspace class.
            jobData = 'job_test.dat';
            
            % Volume of each cell - used to verify density
            load('volumeMatrix', 'volumeMatrix');
            
            for aa = 1:numel(airspace) % Loop through airspace files
                % Initialize traffic density object
                td = TrafficDensity(jobData);
                td.filenames.cell = 'testData.mat';
                td.filenames.cellAirspace = ['testAirspace' airspace{aa} '.mat'];
                td.filenames.cellCoverage = 'testCellCoverage.mat';
                td.area = struct('LatitudeLimit',[48.4,50],'LongitudeLimit',[-127,-125.4]);
                
                % Compute max, yearly average, upper bound of confidence interval, and standard deviation
                td.computemax = true;
                td.computeub = true;
                td.computestd = true;
                td = td.run; % Execute processing

                % Save density plots by figure number in desired folder
                saveas(figure(1),[saveDirectory,'Discrete_' airspace{aa}]);
                saveas(figure(2),[saveDirectory,'1200_' airspace{aa}]);
                close all;

                % Process noncooperative data (plots only)
                td.processNoncoop = true;
                td.plot;
                saveas(figure(3),[saveDirectory,'NonCoop_' airspace{aa}]); % Density heat maps will look the same as 1200-code maps because noncoop is estimated as directly proportional to 1200-code density. However, the colormap scale will be different
                close all;
                
                % Plot the airspace class of each cell
                td.plot('plottype','airspace');
                saveas(figure(1),[saveDirectory,'AirspaceA_',airspace{aa}]);
                saveas(figure(2),[saveDirectory,'AirspaceB_',airspace{aa}]);
                saveas(figure(3),[saveDirectory,'AirspaceC_',airspace{aa}]);
                saveas(figure(4),[saveDirectory,'AirspaceD_',airspace{aa}]);
                saveas(figure(5),[saveDirectory,'AirspaceO_',airspace{aa}]);
                close all;
                
                % Verify that all density values are computed correctly                
                for currACcat = 1:2 % Discrete and 1200-code
                    
                    countFields = {'c','cmax','cmaxocc','cub','cstd'};
                    densityFields = {'rho','rho_max','rho_max_occ','rhoub','rho_std'};
                    
                    for ff = 1:numel(countFields) %Loop through fields
                        
                        %Check size of density and count matrices
                        testCase.verifySize(td.density(currACcat).(densityFields{ff}),[10, 10, 3]); % Density
                        testCase.verifySize(td.count(currACcat).(countFields{ff}),[10, 10, 3]); % Count
                        
                        %Check computation of density variables
                        testCase.verifyEqual(td.density(currACcat).(densityFields{ff}),td.count(currACcat).(countFields{ff})./volumeMatrix,'AbsTol',1e-6);
            
                    end %End loop through fields
                end %End loop through AC Categories

            end %End loop through test data

            close all
        end
        function testTrajectory(testCase)
            % Test that tool properly computes collision risk for a given
            % track
            %% Set up save directory
            saveDirectory = [getenv('TrafficDensityPath') filesep 'Testing' filesep 'Results' filesep]; % Directory where plots will be saved
            if ~exist(saveDirectory,'dir')
                mkdir(saveDirectory); % Create saveDirectory
            end
            
            close all; % Close all existing plots so we can save the ones generated by the traffic density unit test
            
            %% Generate collision risk for test trajectory
            disp('***Running Trajectory Test***');
            % Initialize traffic density object
            td = TrafficDensity('job_test.dat');
            td.filenames.cell = 'testData.mat';
            td.filenames.cellAirspace = 'testAirspaceAll.mat';
            td.filenames.cellCoverage = 'testCellCoverage.mat';
            td.area = struct('LatitudeLimit',[48.4,50],'LongitudeLimit',[-127,-125.4]);

            % Compute max, yearly average, upper bound of confidence interval, and standard deviation
            td.computemax = true;
            td.computeub = true;
            td.computestd = true;
            
            % Straight-line test trajectory
            t = readtable('testTrack.csv');
            computeinds = 1:15:length(t.time); % Reduce number of points to speed up processing - recommended time between updates is 5-30 s
            
            % Set properties in object
            td.track.Time_s = t.time(computeinds);
            td.track.Latitude_deg = t.lat(computeinds);
            td.track.Longitude_deg = t.lon(computeinds);
            td.track.Altitude_MSL_ft = t.altitude(computeinds);
            td.track.Speed_kts = t.tas(computeinds);
            td.correctcoverage = 0; % Do not correct for radar coverage so that output density will be the same as input data for verification purposes
            td = td.run; % Execute processing

            % Verify correct calculation of collision risk (rate)
            ft2nm = 0.000164578834; % Convert ft --> nm
                         
            for currACcat = 1:2 % Discrete and 1200-Code
                rateFields = {'rateavg','ratemax','ratemaxocc','rateavgub','ratestd'};
                densityFields = {'rho','rho_max','rho_max_occ','rhoub','rho_std'};
                
                rateFactor = 4.*td.macR.*td.macH.*td.relSpeed{currACcat}*ft2nm^2; % For computing collision rate
    
                for ff = 1:numel(rateFields) %Loop through fields

                    %Check size of density and rate matrices are the same
                    testCase.verifySize(td.rate(currACcat).(rateFields{ff}),size(td.density(currACcat).(densityFields{ff}))); 

                    %Check computation of rate variables
                    testCase.verifyEqual(td.rate(currACcat).(rateFields{ff}),td.density(currACcat).(densityFields{ff}).*rateFactor,'AbsTol',1e-6);

                end %End loop through fields
            end

            % Test values match expectations
            testCase.verifyEqual(all(td.count(1).cmaxocc==1),true); 
            
            % Save plots
            saveas(figure(1), [saveDirectory, 'TestTrajectory_Discrete.fig']);
            saveas(figure(2), [saveDirectory, 'TestTrajectory_1200.fig']);
            saveas(figure(3), [saveDirectory, 'TestTrajectory_Aggregate.fig']);

            close all
        end
        function testArea(testCase)
            % Test that tool properly computes density for a given area
            %% Set up save directory
            saveDirectory = [getenv('TrafficDensityPath') filesep 'Testing' filesep 'Results' filesep]; % Directory where plots will be saved
            if ~exist(saveDirectory,'dir')
                mkdir(saveDirectory); % Create saveDirectory
            end           
            close all; % Close all existing plots so we can save the ones generated by the traffic density unit test

            %% Test queries for different positions
            disp('***Running Area Test***');

            % Region - density within this square is positive, 0's everywhere else
            td = TrafficDensity('job_test.dat');
            td.filenames.cell = 'testDataArea.mat';
            td.filenames.cellAirspace = 'testAirspaceAll.mat';
            td.filenames.cellCoverage = 'testCellCoverage.mat'; %Coverage in all cells

            % Evaluate area (based on user specified limits)
            td.area.LatitudeLimit = [48.5,49.5]; 
            td.area.LongitudeLimit = [-126.5, -125.5];
            
            td.correctcoverage = 0; % Do not correct for radar coverage so that output density will be the same as input data for verification purposes
            td = td.run; % Execute processing

            % Save plots
            saveas(figure(1), [saveDirectory, 'TestArea_Discrete.fig']);
            saveas(figure(2), [saveDirectory, 'TestArea_1200.fig']);
            saveas(figure(3), [saveDirectory, 'TestArea_Aggregate.fig']); 

            % Test verification is performed by looking at the output plots (density should be concentrated in the center of the region).
            % Ensure data was filtered to the area of positive data (MaxOcc should range from 1-4):
            testCase.verifyEqual(max(td.count(1).cmaxocc(~isnan(td.count(1).cmaxocc))),4);
            testCase.verifyEqual(min(td.count(1).cmaxocc(~isnan(td.count(1).cmaxocc)&td.count(1).cmaxocc>0)),1);

            close all
        end
        function testTemporal(testCase)
            % Test that tool properly computes density for given temporal
            % characteristics
            %% Set up save directory
            saveDirectory = [getenv('TrafficDensityPath') filesep 'Testing' filesep 'Results' filesep]; % Directory where plots will be saved
            if ~exist(saveDirectory,'dir')
                mkdir(saveDirectory); % Create saveDirectory
            end            
            close all; % Close all existing plots so we can save the ones generated by the traffic density unit test

            %% Test queries for different times
            disp('***Running Temporal Test***');
            load('volumeMatrix', 'volumeMatrix'); % Volume of each cell - used to verify density

            % 1. Month
            % Load test data (Features: data for January = 1, February = 2, ...)
            td = TrafficDensity('job_test.dat');
            td.filenames.cell = 'testDataMonth.mat';
            td.filenames.cellAirspace = 'testAirspaceAll.mat';
            td.filenames.cellCoverage = 'testCellCoverage.mat';
            td.area = struct('LatitudeLimit',[48.4,50],'LongitudeLimit',[-127,-125.4]);
            td.monthofyear = 7; % July
            td.correctcoverage = 0; % Do not correct for radar coverage so that output density will be the same as input data for verification purposes
            td = td.run; % Execute processing

            close all;
            td.plot('plottype','count','plotvalue','maxocc'); %Plot maximum occupancy
            
            % Save plots
            saveas(figure(1), [saveDirectory, 'TestMonth_Discrete.fig']);
            saveas(figure(2), [saveDirectory, 'TestMonth_1200.fig']);

            % Test values match expectations:
            % Check maximum occupancy cell density
            x = (td.density(1).rho_max_occ.*volumeMatrix); % Convert density back to maximum occupancy
            testCase.verifySize(unique(round(x(~isnan(x)))),[1,1]); % Verify size
            testCase.verifyEqual(all(unique(round(x(~isnan(x))))== 7),true); % Verify only contains July data
            % Check maximum occupancy cell count
            testCase.verifySize(unique(td.count(1).cmaxocc(~isnan(td.count(1).cmaxocc))),[1,1]); % Verify size
            testCase.verifyEqual(all(unique(td.count(1).cmaxocc(~isnan(td.count(1).cmaxocc))) == 7),true); % Verify only contains July data

            % 2. Day
            % Load test data (Features: data for Sunday = 1, Monday = 2, ...)
            td = TrafficDensity('job_test.dat');
            td.filenames.cell = 'testDataDay.mat';
            td.filenames.cellAirspace = 'testAirspaceAll.mat';
            td.filenames.cellCoverage = 'testCellCoverage.mat';
            td.area = struct('LatitudeLimit',[48.4,50],'LongitudeLimit',[-127,-125.4]);
            td.dayofweek = 2; % Monday
            td.correctcoverage = 0; % Do not correct for radar coverage so that output density will be the same as input data for verification purposes
            td = td.run; % Execute processing
            
            close all;
            td.plot('plottype','count','plotvalue','maxocc'); %Plot maximum occupancy

            % Save plots
            saveas(figure(1), [saveDirectory, 'TestDay_Discrete.fig']);
            saveas(figure(2), [saveDirectory, 'TestDay_1200.fig']);

            % Test values match expectations:
            % Check maximum occupancy cell density
            x = (td.density(1).rho_max_occ.*volumeMatrix); % Convert density back to maximum occupancy
            testCase.verifySize(unique(round(x(~isnan(x)))),[1,1]); % Verify size
            testCase.verifyEqual(all(unique(round(x(~isnan(x))))== 2),true); % Verify only contains Monday data
            % Check maximum occupancy cell count
            testCase.verifySize(unique(td.count(1).cmaxocc(~isnan(td.count(1).cmaxocc))),[1,1]); % Verify size
            testCase.verifyEqual(all(unique(td.count(1).cmaxocc(~isnan(td.count(1).cmaxocc))) == 2),true); % Verify only contains Monday data

            % 3. Hour - hours are processed in 3-hour bins (8 bins per day)
            % Load test data (Features: data for Bin 1 = 1, Bin 2 = 2, ...)
            td = TrafficDensity('job_test.dat');
            td.filenames.cell = 'testDataHour.mat';
            td.filenames.cellAirspace = 'testAirspaceAll.mat';
            td.filenames.cellCoverage = 'testCellCoverage.mat';
            td.area = struct('LatitudeLimit',[48.4,50],'LongitudeLimit',[-127,-125.4]);
            td.timeofday = 1; % Midnight bin (UTC)
            td.correctcoverage = 0; % Do not correct for radar coverage so that output density will be the same as input data for verification purposes
            td = td.run; % Execute processing

            close all;
            td.plot('plottype','count','plotvalue','maxocc'); %Plot maximum occupancy            
            
            % Save plots
            saveas(figure(1), [saveDirectory, 'TestHour_Discrete.fig']);
            saveas(figure(2), [saveDirectory, 'TestHour_1200.fig']);

            % Test values match expectations:
            % Check maximum occupancy cell density
            x = (td.density(1).rho_max_occ.*volumeMatrix); % Convert desnity back to maximum occupancy
            testCase.verifySize(unique(td.count(1).cmaxocc(~isnan(td.count(1).cmaxocc))),[1,1]); % Verify size
            testCase.verifyEqual(all(unique(td.count(1).cmaxocc(~isnan(td.count(1).cmaxocc))) == 1),true); % Verify only contains Midnight bin data
            % Check maximum occupancy cell count
            testCase.verifySize(unique(round(x(~isnan(x)))),[1,1]); % Verify size
            testCase.verifyEqual(all(unique(round(x(~isnan(x))))==1),true); % Verify only contains Midnight bin data

            close all
        end
        function testMissingData(testCase)
            % Test that tool properly accounts for missing radar coverage
            %% Set up save directory
            saveDirectory = [getenv('TrafficDensityPath') filesep 'Testing' filesep 'Results' filesep]; % Directory where plots will be saved
            if ~exist(saveDirectory,'dir')
                mkdir(saveDirectory); % Create saveDirectory
            end            
            close all; % Close all existing plots so we can save the ones generated by the traffic density unit test

            %% Test missing data
            disp('***Running Missing Data Test***');

            % 1. Empty data
            td = TrafficDensity('job_test.dat');
            td.filenames.cell = 'emptyTest.mat';
            td.filenames.cellCoverage = 'emptyCellCoverage.mat';
            td.filenames.cellAirspace = 'testAirspaceAll.mat';
            td.area = struct('LatitudeLimit',[48.4,50],'LongitudeLimit',[-127,-125.4]);
            td = td.run; % Execute processing

            % Check that missing data %'s match expectations:
            % Plot
            td.plot('plottype','coverage');
            saveas(figure(1), [saveDirectory, 'EmptyDataCoverage_Discrete.fig']);
            saveas(figure(2), [saveDirectory, 'EmptyDataCoverage_1200.fig']);
            saveas(figure(3), [saveDirectory, 'EmptyDataCoverage_Aggregate.fig']);
            saveas(figure(4), [saveDirectory, 'EmptyDataCoverage_RadarCoverage.fig']);

            % Stats
            testCase.verifyEqual(mean(td.cellcoverage<td.noCoverageThreshold,'all'),1);

            % 2. Half-empty data
            td = TrafficDensity('job_test.dat');
            td.filenames.cell = 'halfEmptyTest.mat';
            td.filenames.cellCoverage = 'halfEmptyCellCoverage.mat';
            td.filenames.cellAirspace = 'testAirspaceAll.mat';
            td.area = struct('LatitudeLimit',[48.4,50],'LongitudeLimit',[-127,-125.4]);
            td = td.run; % Execute processing

            % Check that missing data %'s match expectations: 
            % Plot
            td.plot('plottype','coverage');
            saveas(figure(5), [saveDirectory, 'HalfEmptyDataCoverage_Discrete.fig']);
            saveas(figure(6), [saveDirectory, 'HalfEmptyDataCoverage_1200.fig']);
            saveas(figure(7), [saveDirectory, 'HalfEmptyDataCoverage_Aggregate.fig']);
            saveas(figure(8), [saveDirectory, 'HalfEmptyDataCoverage_RadarCoverage.fig']);

            % Stats
            testCase.verifyEqual(round(mean(td.cellcoverage<td.noCoverageThreshold,'all'),1),0.5);

            close all
        end
   end
end